Refer this playlist => https://www.youtube.com/playlist?list=PLbGui_ZYuhij6LpUbWgKUxggL_AuoHHVw

#! INSTALLATION OF DJANGO CHANNELS
1. Install channels using `pip install channels`
2. Now add `channels` in INSTALLED_APPS

#! ASGI
3. In the asgi.py file from the project directory, type the folowing code:
"
from channels.routing import ProtocolTypeRouter
application = ProtocolTypeRouter({
    "http": get_asgi_application(),
    # Just HTTP for now. (We can add other protocols later.)
})
"
4. In settings.py, comment the following code:
"
WSGI_APPLICATION = 'DjangoChannelsWebSocketProject.wsgi.application'
"
5. In settings.py, after commenting the above code, add the following code: 
"
ASGI_APPLICATION = "myprojectname.asgi.application"
"

#! CONSUMERS
6. Now we have to create a consumers.py file in the application directory which acts same as the views.py file. It allows us to series of functions to be called along with sync and async functions.
7. The 3 functions are: websocket_connect, websocket_receive, websocket_disconnect.
8. websocket_connect => This handler is called when client initially opens a connection and is about to finish the WebSocket handshake.
9. websocket_receive => This handler is called when data received from Client.
10. websocket_disconnect => This handler is called when either connection to the client is lost, either from the client closing the connection, the server closing the connection, or loss of the socket.

#! ROUTING
11. Now we have to create a routing.py file in the application directory which acts same as the urls.py file.
12. Add the following code in routing.py:
"
websocket_urlpatterns = [
    path("ws/sc/", consumers.MySyncConsumer.as_asgi()),
    path("ws/ac/", consumers.MyAsyncConsumer.as_asgi()),
]
"
13. Write .as_asgi() in the above code which is the same as .as_view() in the views.py file. This will convert the sync and async functions to ASGI functions.
14. Now go to your asgi.py file and add the following code:
"
from channels.routing import ProtocolTypeRouter

application = ProtocolTypeRouter(
    {
        "http": get_asgi_application(),
        "websocket": URLRouter(
            DjangoChannelsWebSocketApp.routing.websocket_urlpatterns
        ),
    }
)
"
#! NOTE: Uninstall channels using `pip uninstall channels`, then install 'pip install daphne'. Then add 'daphne' at the very beginning in the INSTALLED_APPS of settings.py , again install channels using `pip install channels`.
15. Now go to POSTMAN and send the websocket request to the server using "ws://127.0.0.1:8000/ws/sc/". You can also send data to the server and click the send button.
16. The data send by the user will be in event => {'type': 'websocket.receive', 'text': 'hey ayush, this is message from postman...'}
17. You can get the data by using event[data]
18. Use "self.send({"type": "websocket.accept"})" in the websocket_connect function to accept the connection.
19. Use "raise StopConsumer()" in the websocket_disconnect function to disconnect the connection.
20. Use "await self.send({"type": "websocket.accept"})" in the websocket_connect function to accept the connection for asynchronous functions.
21. Use "self.send({'type':'websocket.send','text':'Message Sent to Client'})" in the websocket_receive function to send data to the client.

#! Real-time Data Example
"
from channels.consumer import SyncConsumer, AsyncConsumer
from channels.exceptions import StopConsumer
from time import sleep
import asyncio

class MySyncConsumer(SyncConsumer):
  def websocket_connect(self, event):
    print('Websocket Connected...', event)
    self.send({
      'type':'websocket.accept',
    })
  
  def websocket_receive(self, event):
    print('Message received from Client', event)
    print(event['text'])
    for i in range(50):
      self.send({
        'type':'websocket.send',
        'text': str(i)
      })
      sleep(1)

  def websocket_disconnect(self, event):
    print('Websocket Disconnected...', event)
    raise StopConsumer()

class MyAsyncConsumer(AsyncConsumer):
  async def websocket_connect(self, event):
    print('Websocket Connected...', event)
    await self.send({
      'type':'websocket.accept',
    })
  
  async def websocket_receive(self, event):
    print('Message received from Client', event)
    print(event['text'])
    for i in range(50):
      await self.send({
        'type':'websocket.send',
        'text': str(i)
      })
      await asyncio.sleep(1)

  async def websocket_disconnect(self, event):
    print('Websocket Disconnected...', event)
    raise StopConsumer()
"
22. time.sleep() is used to create a delay of 1 second between each message sent to the client, but it will not work for asynchronous functions. Use asyncio.sleep() instead for async functions.

#! NOTE: When to use synchronous or asynchronous functions?
1. In general, synchronous functions are used when the task can be completed quickly without blocking other operations, while asynchronous functions are used for tasks that may take some time to complete and should not block the execution of other code.
2. For example, in a web application, you might use a synchronous function to perform a simple calculation that can be done quickly without waiting, like adding two numbers together. On the other hand, you would use an asynchronous function to make an API call to fetch data from a remote server since network requests can take time and you don't want to block the rest of the application while waiting for the response.

#! Handle Websocket from Frontend JavaScript in Django Channels
23. To construct a websocket, use the websocket constructor. For example: var ws = new WebSocket('ws://127.0.0.1:8000/ws/sc/');

a) WebSocket Properties
  1. ReadyState
  2. onopen
  3. onclose
  4. onmessage
  5. onerror

b) WebSocket Methods
  1. send
  2. close

c) WebSocket Events and Event Handlers
  1. open
  2. close
  3. message
  4. error

24. Check templates/index.html for more information.